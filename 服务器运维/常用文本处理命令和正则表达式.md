## awk

awk的指令必须包含在单引号中。

### 基本句式

awk -F'指定输入分隔符'  'BEGIN{做一些初始化工作} 一些过滤条件 {针对每行的工作}... END{最后收尾工作}'

中间的处理块可以有多个，通过过滤条件单每行都会走一遍过滤条件，其中BEGIN和END边只会执行一遍

### 过滤记录

1. awk '$3==0 && $6=="LISTEN" ' netstat.txt
2. awk '$3==0 && $6=="LISTEN" || NR==1 ' netstat.txt

### 指定分隔符

1.  `awk  -F: '{print $1,$3,$6}' /etc/passwd`等价于`awk  'BEGIN{FS=":"} {print $1,$3,$6}' /etc/passwd`
2.  `awk -F '[;:]'` 指定多个分隔符
3.  `awk  -F: '{print $1,$3,$6}' OFS="\t" /etc/passwd`指定输出分隔符

需要注意的是上面`print $1,$3,$6`中的`,`被替换成了分隔符，如果是`print $1$3$6`则中间没有分隔符


### 特殊关键字：
1. NR  目前处理的行号
2. NF  当前处理的行一共用到的字段数目
3. FNR 目前处理的文件的行号（当处理多个文件时，NR会不停的累加，但如果是FNR则在处理新文件是从1开始）
4. FILENAME 文件名
5. $0  当前整行
6. FS  输入字段分隔符 默认是空格或Tab
7. RS   输入记录分隔符 默认为换行符
8. OFS  输出字段分隔符 默认是空格或Tab
9. ORS   输出记录分隔符 默认为换行符

### 正则

1. 普通匹配：    `awk'/hello/ {print}' test.sh`  
2. 匹配取反：    `awk '!/hello/ {print}' test.sh` 
3. 同时匹配：    `awk '/hello/ && /world/ {print}' test.sh`  
3. 或者匹配：    `awk '/hello/ || /world/ {print}' test.sh` 也可以写成`awk '/hello|world/ {print}' test.sh`   
4. 指定列匹配：  `awk '$5 ~ /hello/ {print}' test.sh`
4. 指定列匹配取反：  `awk '$5 !~ /hello/ {print}' test.sh`


### 输出到不同的文件

1. `$ awk 'NR!=1{if($6 ~ /TIME|ESTABLISHED/) print > "1.txt";
 else if($6 ~ /LISTEN/) print > "2.txt";
 else print > "3.txt" }' netstat.txt`
2. `awk 'NR!=1{print > $6}' netstat.txt` 

其实使用了 `>`重定向,上例子使用了if语句

### 统计数据

1. `awk 'NR!=1{a[$6]++;} END {for (i in a) print i ", " a[i];}' netstat.txt`

### 和环境变量的交互

```
$ x=5
 
$ y=10
$ export y
 
$ echo $x $y
5 10
$ awk -v val=$x '{print $1, $2, $3, $4+val, $5+ENVIRON["y"]}' OFS="\t" score.txt
Marry   2143    78      89      87
Jack    2321    66      83      55
Tom     2122    48      82      81
Mike    2537    87      102     105
Bob     2415    40      62      72
```


## grep

参数列表：

1. -w 匹配整个单词
2. -s 忽略文件不存在等报错
3. -l 仅列出匹配文件列表 
4. -L 仅列出不匹配文件列表
5. -A 显示后的行数 如-1 匹配行的后1行
6. -B 显示前的行数 如-1 匹配行的前1行
7. -number 显示前后的行数 如-1 匹配行的前后1行
8. -n 打印行数
9. -c 仅显示个数
10. -v 反向
11. -o 仅显示匹配的内容
12. -E 则表示要使用EREs
13. -P 则表示要使用PREs


grep主要就是一个正则表达式的使用，其中需要注意正则有三种BREs、EREs和PREs。前两种不支持非贪婪匹配。grep默认是BREs，所以他`?,+,|,{,},（,）`
这种字符都需要用`\`转义，另外他不支持`\s，\S，\D，\d,\n`等字符。



## sed



##sort和uniq





这两个命令经常同时使用 

## 实战

### 处理以下文件内容,将域名取出并进行计数排序,如处理:  
http://www.baidu.com/index.<a target="_blank" href="http://www.2cto.com/kf/qianduan/css/" class="keylink" style="border:none; padding:0px; margin:0px; color:rgb(51,51,51); text-decoration:none; font-size:14px">html</a>  
http:  /  /  www.baidu.com/1.html  
http://post.baidu.com/index.html  
http://mp3.baidu.com/index.html  
http://www.baidu.com/3.html  
http://post.baidu.com/2.html  
得到如下结果:    
3 www.baidu.com  
2 post.baidu.com  
1 mp3.baidu.com  


解法1：`grep -Po  '(?<=//)(.*?)(?=/)' test.txt |sort |uniq -c|sort -nr`     
> 1.利用了Perl，他支持非贪婪，2.利用了正向和反向预查（正向预查是后面的(?=)) 3.利用了-o参数只输出匹配的内容     

解法2：`awk -F/ '{print $3}' test.txt |sort |uniq -c|sort -nr`       
> 指明了分割符号 直接取对应值     

解法3：`sed  's/http:\/\/\([^/]*\).*/\1/' test.txt|sort |uniq -c|sort -nr`         
> 基本的正则中小括号需要转义，如果采用-r参数即扩展的正则小括号不用转义

解法4： `sed -e 's/http:\/\///' -e 's/\/.*//' | sort | uniq -c | sort -rn`   
> 采用了替换，先替换前面的，在替换后面的 




### 用grep结合sed取出网卡的ip地址  
[root@jie1 ~]# ifconfig | grep -B1 "inet addr" |grep -v "\-\-" |sed -n -e 'N;s/eth[0−9].*\n.*addr:[0−9]{1,3}\.[0−9]{1,3}\.[0−9]{1,3}\.[0−9]{1,3}.*/\1 \2/p'  


### 删除文件中空白行（只包含空格和Tab等字符的行也需要删除）

替换空行 ^\n




参考资料：
1. [AWK 简明教程](https://coolshell.cn/articles/9070.html)
2. 