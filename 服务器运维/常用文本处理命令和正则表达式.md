## 处理以下文件内容,将域名取出并进行计数排序,如处理:  
http://www.baidu.com/index.<a target="_blank" href="http://www.2cto.com/kf/qianduan/css/" class="keylink" style="border:none; padding:0px; margin:0px; color:rgb(51,51,51); text-decoration:none; font-size:14px">html</a>  
http:  /  /  www.baidu.com/1.html  
http://post.baidu.com/index.html  
http://mp3.baidu.com/index.html  
http://www.baidu.com/3.html  
http://post.baidu.com/2.html  
得到如下结果:    
3 www.baidu.com  
2 post.baidu.com  
1 mp3.baidu.com  



解法1：`grep -Po  '(?<=//)(.*?)(?=/)' test.txt |sort |uniq -c|sort -nr`     
> 1.利用了Perl，他支持非贪婪，2.利用了正向和反向预查（正向预查是后面的(?=)) 3.利用了-o参数只输出匹配的内容     

解法2：`awk -F/ '{print $3}' test.txt |sort |uniq -c|sort -nr`       
> 指明了分割符号 直接取对应值     

解法3：`sed  's/http:\/\/\([^/]*\).*/\1/' test.txt|sort |uniq -c|sort -nr`         
> 基本的正则中小括号需要转义，如果采用-r参数即扩展的正则小括号不用转义

解法4： `sed -e 's/http:\/\///' -e 's/\/.*//' | sort | uniq -c | sort -rn`   
> 采用了替换，先替换前面的，在替换后面的 




## 用grep结合sed取出网卡的ip地址  
[root@jie1 ~]# ifconfig | grep -B1 "inet addr" |grep -v "\-\-" |sed -n -e 'N;s/eth[0−9].*\n.*addr:[0−9]{1,3}\.[0−9]{1,3}\.[0−9]{1,3}\.[0−9]{1,3}.*/\1 \2/p'  


## 删除文件中空白行（只包含空格和Tab等字符的行也需要删除）




正则有三种  BREs、EREs和PREs。前两种不只是非贪婪匹配。

替换空行 ^\n

常用的特殊字符：

\n
\s
\S
\D
\d

**sort**

**uniq** 


**sed**

**awk**

**grep**

-w 匹配整个单词
-s 忽略文件不存在等报错
-l 仅列出匹配文件列表 
-L 仅列出不匹配文件列表
-A 
-B
-number 显示前后的行数 如-1 匹配行的前后1行
-n 打印行数
-c 仅显示个数
-v 反向
-o 仅显示匹配的内容

**cut**


